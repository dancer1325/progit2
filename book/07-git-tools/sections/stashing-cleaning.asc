[[_git_stashing]]
=== Stashing and Cleaning

* use cases
    ** you've been working about part of your project & you need to switch branches / you do NOT want to do a commit of half-done work

* how does it work?
    ** your modified tracked files & staged changes -- are saved them -- | stack of unfinished changes / you can reapply | any time & any branch

* `git stash save`
    ** -- is going to be migrated to -> `git stash push`
        *** == `git stash save` is being deprecated
        ** Reason: üß†`git stash push` allows stashing selected _pathspecs_ / NOT supported by `git stash save` üß†

* `git stash apply stashName`
    ** reapply the stash / stored
        *** if anything no longer applies cleanly -> Git could give you merge conflicts
    ** üëÅÔ∏è if you do NOT specify "stashName" -> last stash stored is applied üëÅÔ∏è
    ** `... --index`
        *** restage the previous staged files
        *** ‚ö†Ô∏èby default, staged files are NOT restaged ‚ö†Ô∏è

* `git stash drop stashName`
    ** remove the stashName from the stack

* `git stash pop`
    ** == `git stash apply` + `git stash drop`
        *** == reapply the last stage & remove it from the stack

* _Example:_ demonstrate stashing
    ** work | your project / stage 1 of the changes
    ** `git status`, checking the dirty state

    [source,console]
    ----
    $ git status
    Changes to be committed:
      (use "git reset HEAD <file>..." to unstage)

        modified:   index.html

    Changes not staged for commit:
      (use "git add <file>..." to update what will be committed)
      (use "git checkout -- <file>..." to discard changes in working directory)

        modified:   lib/simplegit.rb
    ----

    ** you want to switch branches BUT you do NOT want to commit yet -> run `git stash` or `git stash push`

    [source,console]
    ----
    $ git stash
    Saved working directory and index state \
      "WIP on master: 049d078 Create index file"
    HEAD is now at 049d078 Create index file
    (To restore them type "git stash apply")
    ----

    ** now, working directory is clean

    [source,console]
    ----
    $ git status
    # On branch master
    nothing to commit, working directory clean
    ----

    ** you can switch branches & do work
    ** `git stash list`, to check the stashes / stored

    [source,console]
    ----
    $ git stash list
    stash@{0}: WIP on master: 049d078 Create index file
    stash@{1}: WIP on master: c264051 Revert "Add file_size"
    stash@{2}: WIP on master: 21d80a5 Add number to log
    ----

    ** ways to apply some stored stashed
        *** `git stash apply` -> reapply the last one / stashed
        *** `git stash apply stashName` -- `git stash apply stash@{2}` -> reapply specific stashed one

    [source,console]
    ----
    $ git stash apply
    On branch master
    Changes not staged for commit:
      (use "git add <file>..." to update what will be committed)
      (use "git checkout -- <file>..." to discard changes in working directory)

        modified:   index.html
        modified:   lib/simplegit.rb

    no changes added to commit (use "git add" and/or "git commit -a")
    ----

        *** `git stash apply --index` -> reapply stashed changes & restage, staged files

    [source,console]
    ----
    $ git stash apply --index
    On branch master
    Changes to be committed:
      (use "git reset HEAD <file>..." to unstage)

        modified:   index.html

    Changes not staged for commit:
      (use "git add <file>..." to update what will be committed)
      (use "git checkout -- <file>..." to discard changes in working directory)

        modified:   lib/simplegit.rb
    ----

    ** `git stash drop stashName`, to remove the stashName from the stack

    [source,console]
    ----
    $ git stash list
    stash@{0}: WIP on master: 049d078 Create index file
    stash@{1}: WIP on master: c264051 Revert "Add file_size"
    stash@{2}: WIP on master: 21d80a5 Add number to log
    $ git stash drop stash@{0}
    Dropped stash@{0} (364e91f3f268f0900bc3ee613f9f733e82aaed43)
    ----

==== Creative Stashing

* TODO:

There are a few stash variants that may also be helpful.
The first option that is quite popular is the `--keep-index` option to the `git stash` command.
This tells Git to not only include all staged content in the stash being created, but simultaneously leave it in the index.

[source,console]
----
$ git status -s
M  index.html
 M lib/simplegit.rb

$ git stash --keep-index
Saved working directory and index state WIP on master: 1b65b17 added the index file
HEAD is now at 1b65b17 added the index file

$ git status -s
M  index.html
----

Another common thing you may want to do with stash is to stash the untracked files as well as the tracked ones.
By default, `git stash` will stash only modified and staged _tracked_ files.
If you specify `--include-untracked` or `-u`, Git will include untracked files in the stash being created.
However, including untracked files in the stash will still not include explicitly _ignored_ files; to additionally include ignored files, use `--all` (or just `-a`).

[source,console]
----
$ git status -s
M  index.html
 M lib/simplegit.rb
?? new-file.txt

$ git stash -u
Saved working directory and index state WIP on master: 1b65b17 added the index file
HEAD is now at 1b65b17 added the index file

$ git status -s
$
----

Finally, if you specify the `--patch` flag, Git will not stash everything that is modified but will instead prompt you interactively which of the changes you would like to stash and which you would like to keep in your working directory.

[source,console]
----
$ git stash --patch
diff --git a/lib/simplegit.rb b/lib/simplegit.rb
index 66d332e..8bb5674 100644
--- a/lib/simplegit.rb
+++ b/lib/simplegit.rb
@@ -16,6 +16,10 @@ class SimpleGit
         return `#{git_cmd} 2>&1`.chomp
       end
     end
+
+    def show(treeish = 'master')
+      command("git show #{treeish}")
+    end

 end
 test
Stash this hunk [y,n,q,a,d,/,e,?]? y

Saved working directory and index state WIP on master: 1b65b17 added the index file
----

==== Creating a Branch from a Stash

If you stash some work, leave it there for a while, and continue on the branch from which you stashed the work, you may have a problem reapplying the work.
If the apply tries to modify a file that you've since modified, you'll get a merge conflict and will have to try to resolve it.
If you want an easier way to test the stashed changes again, you can run `git stash branch <new branchname>`, which creates a new branch for you with your selected branch name, checks out the commit you were on when you stashed your work, reapplies your work there, and then drops the stash if it applies successfully:

[source,console]
----
$ git stash branch testchanges
M	index.html
M	lib/simplegit.rb
Switched to a new branch 'testchanges'
On branch testchanges
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

	modified:   index.html

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

	modified:   lib/simplegit.rb

Dropped refs/stash@{0} (29d385a81d163dfd45a452a2ce816487a6b8b014)
----

This is a nice shortcut to recover stashed work easily and work on it in a new branch.

[[_git_clean]]
==== Cleaning your Working Directory

Finally, you may not want to stash some work or files in your working directory, but simply get rid of them; that's what the `git clean` command is for.

Some common reasons for cleaning your working directory might be to remove cruft that has been generated by merges or external tools or to remove build artifacts in order to run a clean build.

You'll want to be pretty careful with this command, since it's designed to remove files from your working directory that are not tracked.
If you change your mind, there is often no retrieving the content of those files.
A safer option is to run `git stash --all` to remove everything but save it in a stash.

Assuming you do want to remove cruft files or clean your working directory, you can do so with `git clean`.
To remove all the untracked files in your working directory, you can run `git clean -f -d`, which removes any files and also any subdirectories that become empty as a result.
The `-f` means 'force' or "`really do this,`" and is required if the Git configuration variable `clean.requireForce` is not explicitly set to false.

If you ever want to see what it would do, you can run the command with the `--dry-run` (or `-n`) option, which means "`do a dry run and tell me what you _would_ have removed`".

[source,console]
----
$ git clean -d -n
Would remove test.o
Would remove tmp/
----

By default, the `git clean` command will only remove untracked files that are not ignored.
Any file that matches a pattern in your `.gitignore` or other ignore files will not be removed.
If you want to remove those files too, such as to remove all `.o` files generated from a build so you can do a fully clean build, you can add a `-x` to the `clean` command.

[source,console]
----
$ git status -s
 M lib/simplegit.rb
?? build.TMP
?? tmp/

$ git clean -n -d
Would remove build.TMP
Would remove tmp/

$ git clean -n -d -x
Would remove build.TMP
Would remove test.o
Would remove tmp/
----

If you don't know what the `git clean` command is going to do, always run it with a `-n` first to double check before changing the `-n` to a `-f` and doing it for real.
The other way you can be careful about the process is to run it with the `-i` or "`interactive`" flag.

This will run the `clean` command in an interactive mode.

[source,console]
----
$ git clean -x -i
Would remove the following items:
  build.TMP  test.o
*** Commands ***
    1: clean                2: filter by pattern    3: select by numbers    4: ask each             5: quit
    6: help
What now>
----

This way you can step through each file individually or specify patterns for deletion interactively.

[NOTE]
====
There is a quirky situation where you might need to be extra forceful in asking Git to clean your working directory.
If you happen to be in a working directory under which you've copied or cloned other Git repositories (perhaps as submodules), even `git clean -fd` will refuse to delete those directories.
In cases like that, you need to add a second `-f` option for emphasis.
====
